# Implement a simple Monte-Carlo method that generates standard random walks of length L and estimates the fraction of self-avoiding walks.


import numpy as np


# Generate a random walk of length L.
# If the random walk reaches length L without any self-intersection, it is a self-avoiding walk.
# Although the number of steps needed for a walk to self-intersect is not required, we return this value out of convenience and to exit the function.
def generate_random_walk(L):
    pos = (0, 0)
    s = {(0, 0)}
    steps = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    while len(s) < L + 1:
        next_step = steps[np.random.randint(4)]
        pos = (pos[0] + next_step[0], pos[1] + next_step[1])
        if pos in s:
            return len(s) - 1
        s.add(pos)
    return "AVOIDING"


# Count the number of random walks of length L generated by a specified number of trials.
# Divide by the number of trials to obtain an estimate for the probability that a walk of length L is self-avoiding.
def simple_estimate(L, trials):
    count = 0
    for _ in range(trials):
        if generate_random_walk(L) == "AVOIDING":
            count += 1
    return count / trials


# Estimate the probability that a random walk of length 10 is self-avoiding using Monte Carlo with 100000 trials.
print(simple_estimate(10, 100000))
